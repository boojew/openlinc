#! /usr/bin/perl
#
# A program to generate C source and header files
# from a .idx file.
#
# Created by Martin Oldfield, 2007-11-29
#
# History
#
#  2007-12-02 0.1.0  MJO     Original version
#
#  2008-01-09 0.1.1  FEj+MJO Handle foo(1) style tags
#                            Written by FEj, tweaked and applied by MJO
# 
use strict;
use warnings;

use Template;
use Getopt::Long;
use Pod::Usage;
use YAML;

use version; our $VERSION = qv('0.1.1');

my %Opt;
GetOptions(\%Opt, "help!", "info!", "verbose!", "scaffold=s", "test_html=s", "version!")
  or pod2usage();

if ($Opt{version})
  {
    print "Version $VERSION\n";
    exit;
  }

pod2usage(verbose => 2)
  if $Opt{help} || $Opt{info};

my $tag_file = shift(@ARGV)
  or pod2usage;

(my $stem = $tag_file) =~ s/\.idx$//
  or pod2usage(-msg => "The IDX file must have a .idx extension");

my $tags = parse_tagfile($tag_file);

my %files = ( 
              tag      => $tag_file, 
              header   => "$stem.h", 
              source   => "${stem}_table.c",
             );

my $did_something;
if (my $file = $Opt{scaffold})
  {
    die "Refusing to overwrite $file with scaffold file\n"
      if -e $file;

    print "Writing scaffold file to $file\n" if $Opt{verbose};

    dump_sfile($file, $tags, \%files);
    $did_something++;
  }

if (my $file = $Opt{test_html})
  {
    print "Writing HTML test file to $file\n" if $Opt{verbose};

    dump_tfile($file, $tags, \%files);
    $did_something++;  
  }

unless ($did_something)
  {
    print "Writing header file to $files{header}\n" if $Opt{verbose};
    dump_hfile($tags, \%files);
    print "Writing despatch table to $files{source}\n" if $Opt{verbose};
    dump_cfile($tags, \%files);
  }

# Dump the header file
sub dump_hfile
  {
    my ($tags, $files) = @_;

    my $declr_list = join("", map { "$_;\n" } get_declarations($tags));

    dump_file($files->{header}, <<"EOF");
/**************************************************************
 * $files->{header}
 * Provides callback headers for user's custom
 * HTTP Application.
 * 
 * This file is automatically generated from $files->{tag}
 * ALL MODIFICATIONS WILL BE OVERWRITTEN!
 **************************************************************/

#ifndef __HTTPPRINT_H
#define __HTTPPRINT_H

#include "TCPIP Stack/TCPIP.h"

#if defined(STACK_USE_HTTP2_SERVER)

extern HTTP_CONN curHTTP;
extern HTTP_STUB httpStubs[MAX_HTTP_CONNECTIONS];
extern BYTE curHTTPID;

void HTTPPrint(DWORD callbackID);

$declr_list
#endif

#endif

EOF
  }

# Given a list of tags, return a sorted list of declarations 
# removing any duplications
sub get_declarations
  {
    my $tags = shift;

    my %decl;
    foreach my $t (values %$tags)
      {
        next unless $t->{decl};
        $decl{$t->{decl}}++;
      }
    
    return sort keys  %decl;
  }    

# Dump the C file containing the despatch table
sub dump_cfile
  {
    my ($tags, $files) = @_;

    my $switch_body = "";
    my $pre = "       ";
    foreach my $tag (sort { $tags->{$a}->{n} <=> $tags->{$b}->{n} } keys %$tags)
      {
        my $t = $tags->{$tag};

        my $hex_tag_number = sprintf "0x%x", $t->{n};

        my $fn = $t->{call} || qq{/* unable to handle $tag */};
                        
        $switch_body .= <<"EOF";
       case $hex_tag_number:
         $fn
         break;
EOF
      }

    dump_file($files->{source}, <<"EOF");
/**************************************************************
 * $files->{source}
 * Provides despatch table for custom functions in 
 * HTTP Application.
 * 
 * This file is automatically generated from $files->{tag}.
 * ALL MODIFICATIONS WILL BE OVERWRITTEN!
 **************************************************************/

#include "$files->{header}"
#include "TCPIP Stack/TCPIP.h"

void HTTPPrint(DWORD callbackID)
{
   switch (callbackID)
     {
$switch_body
       default:
	 TCPPutROMArray(sktHTTP, (ROM BYTE*)"!DEF", 4);
     }
}
EOF
  }

# Dump a scaffold file: all the callbacks with trivial bodies
sub dump_sfile
  {
    my ($file, $tags, $files) = @_;

    my $body = "";
    foreach my $decl (get_declarations($tags))
      {
        my $msg = $decl;
        $msg =~ s/^.*?_//;
        $msg =~ s/\(void\)$//;

        my $length = length($msg);

        $body .= <<"EOF";
$decl
  {
    TCPPutROMArray(sktHTTP, (ROM BYTE *)"$msg", $length);
  }

EOF
      }

    dump_file($file, <<"EOF");
/**************************************************************
 * $file
 * 
 * Automatically generated framework: just add proper function
 * definitions.
 * 
 * This file is automatically generated from $files->{tag}.
 **************************************************************/

#include "$files->{header}"
#include "TCPIP Stack/TCPIP.h"

$body
EOF
  }

# Dump some HTML which exercises all the tags
sub dump_tfile
  {
    my ($file, $tags, $files) = @_;

    my @tags = sort { $tags->{$a}->{n} <=> $tags->{$b}->{n} } 
               grep { $_ && !/^inc:/ }
               keys %$tags;
 
    my $body = "";
    foreach my $tag (@tags)
      {
        $body .= <<"EOF";
<tr><th>$tag</th><td>~$tag~</td></th></tr>
EOF
      }

    dump_file($file, <<"EOF");
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 STRICT//EN" "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Server side tag test</title>
  </head>
  <body>
    <h1>Server side tag test</h1>

    <p>The tags below are available for your enjoyment.</p>

    <table>
$body
    </table>
    <hr />
    <p>Generated from $files->{tag}.</p>
  </body>
</html>
EOF
  }

sub dump_file
  {
    my ($file, $text) = @_;
    
    open(my $fh, ">", $file)
      or die "Can't open $file: $!\n";
    
    print {$fh} $text;
  }

# Given the name of a file, return a hash from tag name
# (i.e. something we might find between ~ in the file) to the tag
# number, a declaration for the tag, and the code to call it.
#
# Note that multiple tags may have the same declaration 
# e.g. foo(1) and foo(2)
#
sub parse_tagfile
  {
    my $file = shift;
    
    die "Tagfile $file isn't readable\n"
      unless $file;

    local $/;
    open(my $fh, "<", $file)
      or die "Unable to read tagfile $file: $!\n";

    my $tag_list = <$fh>;
    $tag_list =~ s/\s*//g; # Ignore white space

    my %tag;  # Hash from tag to number
    my %stem; # Hash from stem to declaration
    my $i = 0;
    foreach my $tag (split(/\|/, $tag_list))
      {
        next unless $tag;

        my ($stem, $rest) = ($tag =~ /^(inc:|\w+)(.*)$/);
        
        my ($decl, $call) = ($stem eq "inc:")      ? (undef,                         qq{HTTPIncFile((ROM BYTE *)"$rest");})
                          : ($rest =~ /^\(\d+\)$/) ? ("void HTTPPrint_$stem(int x)", "HTTPPrint_$tag;")
                          : ($rest =~ /^(\(\))?$/) ? ("void HTTPPrint_$stem(void)",  "HTTPPrint_$stem();")
                          :                          (undef, undef);

        $tag{$tag} = { n => $i++, decl => $decl, call => $call };
        $stem{$stem}->{$decl}++ if $decl;
      }

    # Check that we don't have e.g. foo() and foo(1)
    my @multi = grep { scalar keys %{$stem{$_}} > 1 } keys %stem;
    die "Inconsistent signatures found for " . join(", ", sort @multi) . "\n"
      if @multi;

    return \%tag;
  }

__END__

=head1 NAME
 
mpfs2-make-code - Process Microchip HHTP2 IDX file
  
=head1 SYNOPSIS

    # Normal operation 
    mpfs2-make-code foo.idx

    # Generate scaffolding C file 
    mpfs2-make-code foo.idx --scaffold=stubs.c

    # Generate HTML file which exercises all the tags
    mpfs2-make-code foo.idx --html=test.htm

    # Get documentation
    mpfs2-make-code --help

=head1 DESCRIPTION

The HTTP server in Microchip's TCP-IP stack provides a mechanism for
server side includes: things like ~foo~ will be replaced with other
text e.g. a sensor reading or the contents of another file. Formally,
a subroutine provides the replacement for each tag.

Canonically the tags are listed in the HTTPPrint.idx file. This
program generates C code: a header file containing prototypes, and a
source file containing a dispatch table for the subroutines.

This is slighly different to the MPFS2.exe program's approach, which
puts both the prototypes and the table in the same header file.

Optionally, the program will other files instead.

=over

=item A scaffold file

C source for all the subroutines, with trivial function bodies. All
that you have to do is delete those which are already defined, and
replace those which are left with something more useful. 

=item A HTML test file

A simple HTML file which contains all the ~foo~ tags.

=back

=head1 REQUIRED ARGUMENTS

Only one argument is necessary: the name of the .idx file which
contains the list of tags. If this file isn't specified, or if it's
empty then the program will terminate. Typically the key thing here is
the path the file: the file is almost always called HTTPPrint.idx.

This name also sets the name of generated C files. If the index file
is called foo.idx, then the C files will be called foo.h and
foo_table.h. If the scaffold file is generated, it will be called
foo_code.c. If the test file is generated, it will be called foo_test.htm.

=head1 OPTIONS

=over

=item --scaffold

Generate the scaffold file. If this is specified the foo_table.h and
foo_code.c files will not be generated.

=item --test

Generate the test file.  If this is specified the foo_table.h and
foo_code.c files will not be generated.

=item --help

=item --info

Display this manpage.

=item --verbose

Display more information as the program runs.

=item --version

Display version number.

=back
 
=head1 DEPENDENCIES

We use L<Getopt::Long> to parse the arguments, and L<Pod::Usage> to
display usage information and help.

=head1 BUGS AND LIMITATIONS

There are no known bugs in this application.

Arguably we ought to be able to set the output file names
independently.

Please report problems to the author.

Patches are welcome.
 
=head1 AUTHOR

Martin Oldfield, m@mjo.tc.
 
=head1 LICENCE AND COPYRIGHT
 
Copyright (c) 2007 Martin Oldfield. All rights reserved.
 
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See L<perlartistic>.
 
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 


